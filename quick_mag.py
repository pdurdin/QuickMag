# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QuickMag
								 A QGIS plugin
 Parses ASC file and generates raster
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
							  -------------------
		begin				 : 2025-06-28
		git sha				 : $Format:%H$
		copyright			 : (C) 2025 by P Durdin and A Durdin
		email				 : pdurdin@gmail.com
 ***************************************************************************/

/***************************************************************************
 *																		   *
 *	 This program is free software; you can redistribute it and/or modify  *
 *	 it under the terms of the GNU General Public License as published by  *
 *	 the Free Software Foundation; either version 2 of the License, or	   *
 *	 (at your option) any later version.								   *
 *																		   *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QMessageBox

from qgis.core import QgsMessageLog, QgsMapLayerProxyModel

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .quick_mag_dialog import QuickMagDialog
import os.path


from qgis.core import QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsGeometry, QgsPointXY
from qgis.core import QgsProject, QgsVectorLayer, QgsField, QgsFeature, QgsRasterLayer, QgsSingleBandGrayRenderer, QgsContrastEnhancement, QgsVectorFileWriter, QgsProcessingUtils
from qgis.PyQt.QtCore import QVariant, QMetaType

from math import sqrt
from datetime import datetime
import time
import csv
from itertools import groupby
import statistics
import processing

from numpy.polynomial.polynomial import polyfit, polyval
from numpy import percentile

class QuickMag():
	"""QGIS Plugin Implementation."""

	def __init__(self, iface):
		"""Constructor.

		:param iface: An interface instance that will be passed to this class
			which provides the hook by which you can manipulate the QGIS
			application at run time.
		:type iface: QgsInterface
		"""
		# Save reference to the QGIS interface
		self.iface = iface
		# initialize plugin directory
		self.plugin_dir = os.path.dirname(__file__)
		# initialize locale
		locale = QSettings().value('locale/userLocale')[0:2]
		locale_path = os.path.join(
			self.plugin_dir,
			'i18n',
			'QuickMag_{}.qm'.format(locale))

		if os.path.exists(locale_path):
			self.translator = QTranslator()
			self.translator.load(locale_path)
			QCoreApplication.installTranslator(self.translator)

		# Declare instance attributes
		self.actions = []
		self.menu = self.tr(u'&QuickMag')

		# Check if plugin was started the first time in current QGIS session
		# Must be set in initGui() to survive plugin reloads
		self.first_start = None
		
		# create variables
		self.layerName = None
		self.layerGroup = None
		self.data = None
		self.filepath = None
		self.trendRemoval = False		# do not attempt trend removal by default
		self.defaultDisplayRange = 3.0	# default layer symbology min/max
		self.pointSpacing = 0.125		# default minimum point spacing in metres
		self.trendPercentile = 10		# default percentile to exclude from trend calculations
		self.trendDegree = 2			# default nth degree for polynomial fit
		self.highPassSize = 35			# default high pass filter size

	# noinspection PyMethodMayBeStatic
	def tr(self, message):
		"""Get the translation for a string using Qt translation API.

		We implement this ourselves since we do not inherit QObject.

		:param message: String for translation.
		:type message: str, QString

		:returns: Translated version of message.
		:rtype: QString
		"""
		# noinspection PyTypeChecker,PyArgumentList,PyCallByClass
		return QCoreApplication.translate('QuickMag', message)


	def add_action(
		self,
		icon_path,
		text,
		callback,
		enabled_flag=True,
		add_to_menu=True,
		add_to_toolbar=True,
		status_tip=None,
		whats_this=None,
		parent=None):
		"""Add a toolbar icon to the toolbar.

		:param icon_path: Path to the icon for this action. Can be a resource
			path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
		:type icon_path: str

		:param text: Text that should be shown in menu items for this action.
		:type text: str

		:param callback: Function to be called when the action is triggered.
		:type callback: function

		:param enabled_flag: A flag indicating if the action should be enabled
			by default. Defaults to True.
		:type enabled_flag: bool

		:param add_to_menu: Flag indicating whether the action should also
			be added to the menu. Defaults to True.
		:type add_to_menu: bool

		:param add_to_toolbar: Flag indicating whether the action should also
			be added to the toolbar. Defaults to True.
		:type add_to_toolbar: bool

		:param status_tip: Optional text to show in a popup when mouse pointer
			hovers over the action.
		:type status_tip: str

		:param parent: Parent widget for the new action. Defaults None.
		:type parent: QWidget

		:param whats_this: Optional text to show in the status bar when the
			mouse pointer hovers over the action.

		:returns: The action that was created. Note that the action is also
			added to self.actions list.
		:rtype: QAction
		"""

		icon = QIcon(icon_path)
		action = QAction(icon, text, parent)
		action.triggered.connect(callback)
		action.setEnabled(enabled_flag)

		if status_tip is not None:
			action.setStatusTip(status_tip)

		if whats_this is not None:
			action.setWhatsThis(whats_this)

		if add_to_toolbar:
			# Adds plugin icon to Plugins toolbar
			self.iface.addToolBarIcon(action)

		if add_to_menu:
			self.iface.addPluginToMenu(
				self.menu,
				action)

		self.actions.append(action)

		return action

	def initGui(self):
		"""Create the menu entries and toolbar icons inside the QGIS GUI."""

		icon_path = ':/plugins/quick_mag/icon.png'
		self.add_action(
			icon_path,
			text=self.tr(u'Process ASC file...'),
			callback=self.run,
			parent=self.iface.mainWindow())

		# will be set False in run()
		self.first_start = True


	def unload(self):
		"""Removes the plugin menu item and icon from QGIS GUI."""
		for action in self.actions:
			self.iface.removePluginMenu(
				self.tr(u'&QuickMag'),
				action)
			self.iface.removeToolBarIcon(action)


	def run(self):
		"""Run method that performs all the real work"""

		# Create the dialog with elements (after translation) and keep reference
		# Only create GUI ONCE in callback, so that it will only load when the plugin is started
		if self.first_start == True:
			self.first_start = False
			self.dlg = QuickMagDialog()
			
			# set filter for raster generation layer combo
			self.dlg.quickMagRasterLayerCombo.setFilters(QgsMapLayerProxyModel.PointLayer)
			self.dlg.quickMagRasterLayerCombo.setLayer(None)
			
			# set filter for high pass filter layer combo
			self.dlg.quickMagHighPassLayerCombo.setFilters(QgsMapLayerProxyModel.RasterLayer)
			self.dlg.quickMagHighPassLayerCombo.setLayer(None)
			
			# connect buttons to functions
			self.dlg.quickMagRun.clicked.connect(self.processASC)
			self.dlg.quickMagRasterButton.clicked.connect(self.generateRasterFromPoints)
			self.dlg.quickMagHighPassButton.clicked.connect(self.highPassSelectedRaster)
			self.dlg.quickMagMergeFilesButton.clicked.connect(self.mergeASCFiles)

		# show the dialog
		self.dlg.show()
		
		# Run the dialog event loop
		result = self.dlg.exec_()
		
		# See if OK was pressed
		if result:
			# Do something useful here - delete the line containing pass and
			# substitute with your code.
			pass
	
	# merge two or more 
	def mergeASCFiles(self):
		import shlex
		
		fileString = self.dlg.quickMagMergeFilesInput.filePath()
		outputFile = self.dlg.quickMagMergeFilesOutput.filePath()
		
		if not fileString or not outputFile:
			QMessageBox.warning(None, "Quick Mag Error", "Please select ASC files to merge and specifiy an output file")
			return False
		
		files = shlex.split(fileString)
		if len(files) <= 1:
			QMessageBox.warning(None, "Quick Mag Error", "Please select two or more ASC files to merge")
			return False
				
		with open(outputFile, 'w') as outfile:
			for fname in files:
				with open(fname) as infile:
					for line in infile:
						outfile.write(line)
		
		self.dlg.quickMagMergeProgressLabel.setText(f"ASC files merged to: {outputFile}")
	
	# generate a raster from an existing points layer
	def generateRasterFromPoints(self):
		selectedLayer = self.dlg.quickMagRasterLayerCombo.currentLayer()
		if selectedLayer is not None:
			
			medianField = self.dlg.quickMagRasterFieldCombo.currentText()
			if medianField is None:
				QMessageBox.warning(None, "Quick Mag Error", "Please select a field to use for interpolation")
				return False
			
			self.layerName = selectedLayer.name()
			
			start = time.time()
			print("Generating raster from points layer...")
		
			self.createLayerGroup()
			
			# interpolate raster
			newRaster = self.genRaster( medianField, namePrefix=medianField )
			
			# update layer symbology to use -3/+3 min max
			self.updateRasterDisplay( newRaster, -self.defaultDisplayRange, self.defaultDisplayRange )
		
			end = time.time()
			print(f"TOTAL DURATION: {end - start:0.2f}s")
			self.dlg.quickMagRasterProgressLabel.setText(f"Raster generated in: {end - start:0.2f}s")
	
	def createLayerGroup(self, groupName=None):
		# create layer group for results with temporary name
		root = QgsProject.instance().layerTreeRoot()
		self.layerGroup = root.addGroup( "Quickmag Output" )
		
		if groupName is None:
			groupName = self.layerName + "-" + datetime.now().strftime('%Y-%m-%d %H:%M')
		
		self.layerGroup.setName( groupName )
	
	def highPassSelectedRaster(self):
		selectedLayer = self.dlg.quickMagHighPassLayerCombo.currentLayer()
		if not selectedLayer:
			QMessageBox.warning(None, "Quick Mag Error", "Please select a raster layer to run a high pass filter on")
			return False
				
		self.layerName = selectedLayer.name()
		rasterLayer = QgsProject.instance().mapLayersByName(self.layerName)[0]

		self.highPassSize = self.dlg.quickMagHighPassFilterSize.value()
		if self.highPassSize % 2 == 0:
			self.highPassSize -= 1
		
		addToGroup = False
		highPassRaster = self.runHighPassFilter( rasterLayer, "", addToGroup )
		self.updateRasterDisplay( highPassRaster, -self.defaultDisplayRange, self.defaultDisplayRange )
		
		self.dlg.quickMagHighPassProgressLabel.setText(f"High pass filter applied to {self.layerName}")
	
	# load and process a full ASC file from scratch
	def processASC(self):
		start = time.time()
		
		medianField = "medianValue"
		
		self.filepath = self.dlg.quickMagFileInput.filePath()
		if not self.filepath:
			QMessageBox.warning(None, "Quick Mag Error", "Please select an ASC file to process")
			return False
		
		# split out input ASC filename and combine with date time for group and layer names
		filename = os.path.basename( self.filepath )
		self.layerName = os.path.splitext( filename )[0]

		# create a layer group to put the results in
		self.createLayerGroup()
		addToGroup = True
		
		if self.dlg.quickMagTrendRemoval.isChecked():
			self.trendRemoval = True
			self.trendPercentile = self.dlg.quickMagTrendPercentile.value()
			self.trendDegree = self.dlg.quickMagTrendDegree.value()
		
		# process ASC file into vector points
		self.loadASC()

		# interpolate raster
		newRaster = self.genRaster( medianField, namePrefix="median" )
		
		# update layer symbology to use -3/+3 min max
		self.updateRasterDisplay( newRaster, -self.defaultDisplayRange, self.defaultDisplayRange )
		
		# run high pass filter if required (default on)
		if self.dlg.quickMagHighPass.isChecked():		
			self.highPassSize = self.dlg.quickMagHighPassSize.value()
			if self.highPassSize % 2 == 0:
				self.highPassSize -= 1
			
			highPassRaster = self.runHighPassFilter( newRaster, "median", addToGroup )
			self.updateRasterDisplay( highPassRaster, -self.defaultDisplayRange, self.defaultDisplayRange )
		
		if self.trendRemoval:
			trendRaster = self.genRaster( field="trendValue", namePrefix="trend" )
			self.updateRasterDisplay( trendRaster, -self.defaultDisplayRange, self.defaultDisplayRange )
			if self.dlg.quickMagHighPass.isChecked():		
				trendHighPassRaster = self.runHighPassFilter( trendRaster, "trend", addToGroup )
				self.updateRasterDisplay( trendHighPassRaster, -self.defaultDisplayRange, self.defaultDisplayRange )
		
		end = time.time()
		print(f"TOTAL DURATION: {end - start:0.2f}s")
		self.dlg.quickMagProgressLabel.setText(f"ASC processed and raster generated in: {end - start:0.2f}s")
	
	# load ASC file, perform median/trend calculations and generate vector points layer with modified values
	def loadASC(self):
		# Sensys ASC files use UTM CRS with the UTM code as the first part of the x value
		# We will extract the UTM code from the first X coordinate, and assume it is the same for every other X coordinate.
		self.utmVal = 0
		self.utmCode = 0
		self.crsASC = None
		self.csrTransform = None

		self.data = []

		# read from file:
		#	0			   1	   2		 3			4
		#	CoordXWithUTM, CoordY, rawValue, traceName, probeNumber
		#
		# converted "reading" in self.data, which will be sorted by traceAndProbe:
		#
		#	0			   1	   2		 3			4			 5				6				7					8
		#	CoordX,		   CoordY, rawValue, traceName, probeNumber, traceAndProbe, decimatedValue, medianRemovedValue, trendRemovedValue
		#	float		   float   float	 str		str			 tuple			float			float				float

		def convertCoords(rawCoordX, rawCoordY):
			rawCoordX = float(rawCoordX)
			if self.utmVal == 0:
				self.utmVal = int(rawCoordX / 1000000)		# UTM value could be 1 or 2 digits
				self.utmCode = int(32600 + self.utmVal)		# codes for UTM CRS are 326xx
			# get x/y coordinates as floats with UTMval removed
			x = rawCoordX - (self.utmVal * 1000000)
			y = float(rawCoordY)
			return (x, y)

		def convertRawLine(rawLine):
			x, y = convertCoords(rawLine[0], rawLine[1])
			rawValue = float(rawLine[2])
			traceName, probeNumber = rawLine[3], rawLine[4]
			traceAndProbe = (traceName, probeNumber)
			# Return a list rather than a tuple so we can fill in the new columns later.
			return [x, y, rawValue, traceName, probeNumber, traceAndProbe, rawValue, 0.0, 0.0]

		def getTraceAndProbe(reading):
			# reading[5] is traceAndProbe
			return reading[5]

		# traceAndProbe -> (x, y)
		lastCoords = {}

		# function to check distance to last saved point.
		def shouldKeepThisLine(reading):
			traceAndProbe = getTraceAndProbe(reading)
			x, y = reading[0], reading[1]
			keep = True
			lastCoordPair = lastCoords.get(traceAndProbe, None)
			if lastCoordPair is not None:
				lastX, lastY = lastCoordPair
				# skip over points closer together than self.pointSpacing (in metres) along one line.
				# This reduces processing time considerably, and mainly accounts for the machine being
				# pushed with speed settings intended for towing at higher speed!
				distance = sqrt( (x - lastX)**2 + (y - lastY)**2 )
				if distance < self.pointSpacing:
					keep = False
			# Remember the last point we kept for the next distance comparison
			if keep:
				lastCoords[traceAndProbe] = (x, y)
			return keep

		start = time.time()
		print("Loading ASC...")

		# read file data into list
		with open( self.filepath ) as csvfile:
			rawLines = csv.reader(csvfile, delimiter = "\t")
			self.data = list( map(convertRawLine, rawLines) )
		
		# sort data by traceAndProbe, unique value for each line of readings combined from trace and probe values
		self.data.sort(key=getTraceAndProbe)

		end = time.time()
		print(f"Duration: {end - start:0.2f}s")
		
		start = time.time()
		print("Implementing moving median corrections...")
		# get moving median values along each line
		movingMedianList = {}
		movingMedianWindow = 5	# 5 points either side of the central point
		
		length = len( self.data )
		for i, reading in enumerate(self.data):
			currentTraceAndProbe = reading[5]
			movingMedianList[currentTraceAndProbe] = []
			for j in range(-movingMedianWindow, movingMedianWindow):
				# don't go beyond start or end of lines
				if i + j < 0 or i + j >= length:
					continue
				if self.data[i + j][5] != currentTraceAndProbe:
					continue
				movingMedianList[reading[5]].append( self.data[i + j][2] )
			reading[6] = statistics.median( movingMedianList[currentTraceAndProbe] )
			movingMedianList[currentTraceAndProbe] = []
			
		end = time.time()
		print(f"Duration: {end - start:0.2f}s")
		
		# decimate data based on distance between points
		# this has to occur AFTER the moving median calculation above, unfortunately!
		self.data = list( filter(shouldKeepThisLine, self.data ) )
		
		# perform median/trend calculations grouped by trace and probe
		start = time.time()
		if self.trendRemoval:
			print("Calculating line medians and trend correction...")
		else:
			print("Calculating line medians...")
		# reading[3] and reading[4] are trace and probe
		for traceAndProbe, group in groupby(self.data, getTraceAndProbe):
			# We need to process the group twice: once to aggregate data, once to store the adjusted values.
			# So it needs to be a list, not just an iterable.
			group = list(group)

			# Pivot the group from a list of rows into a list of columns.
			groupColumns = list( zip(*group) )

			# Extract the decimatedValue column
			lineRawValues = groupColumns[6]
			# get median value for each group
			median = statistics.median( lineRawValues )
			
			# 'group' contains references to the same reading-lists that convertRawLine() created, so we
			# can change each of these reading-lists here.
			for reading in group:
				rawValue = reading[6]			# reading[6] is value modified by the moving median
				reading[7] = rawValue - median	# reading[7] is medianRemovedValue
			
			if self.trendRemoval:
				# store position of first reading in the line
				firstX, firstY = (group[0][0], group[0][1])
				
				# get position of reading along the line
				def getLinePosition(reading):
					x, y = (reading[0], reading[1])
					return sqrt( (x - firstX)**2 + (y - firstY)**2 )

				linePositions = list(map(getLinePosition, group))
				
				# get threshold for trend removal
				trendThresholdMin = percentile( lineRawValues, self.trendPercentile )
				trendThresholdMax = percentile( lineRawValues, 100 - self.trendPercentile )
				
				# filter values to exclude extreme high and low readings from the polynomial calculation
				def filterTrendValues( linePositions, lineRawValues ):
					filteredLinePositions = []
					filteredRawValues = []
					for position, rawValue in zip( linePositions, lineRawValues ):
						if trendThresholdMin < rawValue < trendThresholdMax:
							filteredLinePositions.append( position )
							filteredRawValues.append( rawValue )
					return ( filteredLinePositions, filteredRawValues )
				
				# don't bother trying to do trend calculations on less than 40 readings (roughly 5 metres)!
				if len(linePositions) > 40:
					filteredLinePositions, filteredRawValues = filterTrendValues( linePositions, lineRawValues )
				else:
					filteredLinePositions, filteredRawValues = linePositions, lineRawValues
				
				# apply polynomial fit if there are any values in the list
				if len( filteredLinePositions ) > 0:
					trendCoeffs = polyfit(filteredLinePositions, filteredRawValues, deg=self.trendDegree)
					trendValues = polyval(linePositions, trendCoeffs)
					for i, reading in enumerate(group):
						reading[8] = lineRawValues[i] - trendValues[i]	# reading[8] is trendRemovedValue
				
		end = time.time()
		print(f"Duration: {end - start:0.2f}s")
		
		# generate vector point layer
		start = time.time()
		print("Creating point layer...")
		# get project CRS
		crsProj = QgsCoordinateReferenceSystem(QgsProject.instance().crs().authid())
		
		# create temporary layer( type, name, storage type )
		vlayer = QgsVectorLayer("Point", self.layerName, "memory")
		vlayer.setCrs(crsProj)
		pr = vlayer.dataProvider()
		
		# create attribute fields in the layer
		pr.addAttributes([
			QgsField("x", QMetaType.Type.Double),
			QgsField("y", QMetaType.Type.Double),
			QgsField("rawValue", QMetaType.Type.Double),
			QgsField("trace", QMetaType.Type.QString),
			QgsField("probe", QMetaType.Type.Int),
			QgsField("decimatedValue", QMetaType.Type.Double),
			QgsField("medianValue", QMetaType.Type.Double),
			QgsField("trendValue", QMetaType.Type.Double)
			])
		vlayer.updateFields()
		end = time.time()
		print(f"Duration: {end - start:0.2f}s")
		
		# set up transform from UTM to project CRS
		self.crsASC = QgsCoordinateReferenceSystem(f"EPSG:{self.utmCode}")
		self.crsTransform = QgsCoordinateTransform(self.crsASC, crsProj, QgsProject.instance())
		
		start = time.time()
		print("Generating vector points...")
		# loop through data and create vector point for each row
		for reading in self.data:
			# create vector point
			f = QgsFeature()
			qPoint = QgsPointXY(reading[0], reading[1])
			xPoint = self.crsTransform.transform(qPoint) # coordinate Transform from UTM to project CRS
			f.setGeometry( QgsGeometry.fromPointXY(xPoint) )
			
			f.setAttributes([
				reading[0],
				reading[1],
				reading[2],
				reading[3],
				reading[4],
				reading[6],
				reading[7],
				reading[8]
				])
			pr.addFeature(f)
			
		end = time.time()
		print(f"Duration: {end - start:0.2f}s")
		
		start = time.time()
		print("Saving layer...")
		# update layer extent and add it to the map
		vlayer.updateExtents() 
		
		QgsProject.instance().addMapLayer(vlayer, False)
		self.layerGroup.addLayer(vlayer)
		
		# do not show the points layer by default
		node = QgsProject.instance().layerTreeRoot().findLayer(vlayer)
		if node:
			node.setItemVisibilityChecked(False)
		
		# below code is needed to use SAGA multi b-spline algorithm as it doesn't work on a memory layer
		"""
		options = QgsVectorFileWriter.SaveVectorOptions()
		options.driverName = "ESRI Shapefile"
		QgsVectorFileWriter.writeAsVectorFormatV3(
			vlayer,
			r"D:/sensys/test.shp",
			QgsProject.instance().transformContext(),
			options
			)
		"""
		end = time.time()
		print(f"Duration: {end - start:0.2f}s")
	
	# function to interpolate raster from vector points layer
	def genRaster(self, field = 'medianValue', namePrefix=''):
		start = time.time()
		print(f"Generating {namePrefix} raster...")
		
		# theoretically we can use the currently selected layer
		if self.layerName is None:
			return False
			vlayer = self.iface.layerTreeView().currentLayer() # grabs currently selected layer
		else:
			vlayer = QgsProject.instance().mapLayersByName(self.layerName)[0]
		
		# get points layer extent to allow raster resolution calculation
		ext = vlayer.extent()
		xmin = ext.xMinimum()
		xmax = ext.xMaximum()
		ymin = ext.yMinimum()
		ymax = ext.yMaximum()
		
		# set raster extent and cell size at 0.125 x 0.125m
		extraOpt = "-tr 0.125 0.125 -txe " + str(xmin) + " " + str(xmax) + " -tye " + str(ymin) + " " + str(ymax)
		
		# use IDW interpolation for quick raster generation
		alg = "gdal:gridinversedistancenearestneighbor"
		params = {'INPUT':vlayer,
			'Z_FIELD':field,
			'POWER':2,
			'SMOOTHING':0.1,
			'RADIUS':1.5,
			'MAX_POINTS':30,
			'MIN_POINTS':0,
			'NODATA':9999,
			'OPTIONS':None,
			'EXTRA':extraOpt,
			'DATA_TYPE':5,
			'OUTPUT':'TEMPORARY_OUTPUT'}
		
		results = processing.run( alg, params )
		
		rasterLayer = QgsRasterLayer(results['OUTPUT'], namePrefix + "-" + self.layerName)
		QgsProject.instance().addMapLayer(rasterLayer, False)
		
		self.layerGroup.addLayer( rasterLayer )
		
		end = time.time()
		print(f"Duration: {end - start:0.2f}s")
		
		# saga multi b-spline is trickier, doesn't work on memory layer
		# would also need to be clipped to size using a heatmap raster generated from the same points
		# raster calculator expression: if( heatmap@1 != 9999, layer@1, 9999 )
		"""
		extent = str(xmin) + "," + str(xmax) + "," + str(ymin) + "," + str(ymax) + ""
		outputfile = os.path.dirname( self.filepath ) + "\\" + "temp.sdat"
		print(outputfile)
		
		alg = "sagang:multilevelbspline"
		params = {'SHAPES':r"D:/sensys/test.shp",
			'FIELD':'modifiedVa',
			'TARGET_USER_SIZE':0.2,
			'TARGET_USER_FITS':0,
			'TARGET_OUT_GRID':TEMPORARY_OUTPUT,
			'METHOD':0,
			'EPSILON':0.0001,
			'LEVEL_MAX':12}
		
		results = processing.run( alg, params )
		rasterLayer = QgsRasterLayer(results['TARGET_OUT_GRID'], "raster-" + self.layerName)
		"""
		
		return rasterLayer
	
	# change raster display to fit in min/max values
	def updateRasterDisplay( self, layer = None, newMin = -3.0, newMax = 3.0 ):
		if not layer:
			layer = iface.layerTreeView().currentLayer()
		
		renderer = QgsSingleBandGrayRenderer(layer.dataProvider(), 1)
		ce = QgsContrastEnhancement(layer.dataProvider().dataType(0))
		ce.setContrastEnhancementAlgorithm(QgsContrastEnhancement.StretchToMinimumMaximum)
		ce.setMinimumValue(newMin)
		ce.setMaximumValue(newMax)
		renderer.setGradient(QgsSingleBandGrayRenderer.WhiteToBlack)
		renderer.setContrastEnhancement(ce)
		
		layer.setRenderer(renderer)
		layer.triggerRepaint()
		
		# collapse node on layers list
		node = QgsProject.instance().layerTreeRoot().findLayer(layer)
		if node:
			node.setExpanded(False)
	
	# use Whitebox Workflows high pass median filter
	def runHighPassFilter( self, layer = None, namePrefix = '', groupExists = False ):
		if not layer:
			QMessageBox.warning(None, "Quick Mag Error", "Please select a layer to run a high pass filter on")
			return False
		
		start = time.time()
		print(f"Generating high pass filtered raster...")
		
		alg = "wbw:high_pass_median_filter"
		params = {
			'inputRaster1':layer,
			'filter_size_x2':self.highPassSize,
			'filter_size_y3':self.highPassSize,
			'sig_digits4':1,
			'fnOutput':QgsProcessingUtils.generateTempFilename('highpass-output.tif')
			}

		results = processing.run( alg, params )
		# print(results)
		rasterLayer = QgsRasterLayer(results['fnOutput'], f"highpass-{self.highPassSize}-{namePrefix}-{self.layerName}")
		
		
		if groupExists is not False:
			QgsProject.instance().addMapLayer(rasterLayer, False)
			self.layerGroup.addLayer( rasterLayer )
		else:
			QgsProject.instance().addMapLayer(rasterLayer, True)
		
		end = time.time()
		print(f"Duration: {end - start:0.2f}s")
		
		return rasterLayer
		
		